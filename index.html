<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />

  <title>Socionics Typing v2.5</title>
  <meta name="theme-color" content="#ff4fd8" />

<style>
:root{
  /* Dark theme base colors */
  --bg-dark:#0b1020;
  --bg-medium:#121a33;
  --bg-light:#1a2341;
  --text-primary:#eaf0ff;
  --text-secondary:#a8b3d3;
  --text-muted:#6b7aa1;
  --panel-dark:rgba(26,35,65,0.8);
  --panel-light:rgba(255,255,255,0.08);
  --border-dark:rgba(255,255,255,0.1);
  --border-light:rgba(255,255,255,0.05);

  /* Quadra colors */
  --q-alpha:#ff5db1;
  --q-beta:#4aa3ff;
  --q-gamma:#ffd24a;
  --q-delta:#43e07a;

  /* Accent gradients */
  --hi:#ff5db1;
  --hi2:#4aa3ff;
  --hi3:#ffd24a;
  --hi4:#43e07a;

  /* Shadows and glows */
  --shadow-dark:0 20px 60px rgba(0,0,0,0.4);
  --shadow-neon:0 0 30px rgba(255,93,179,0.3), 0 0 60px rgba(74,163,255,0.2);
  --glow-alpha:0 0 20px rgba(255,93,179,0.4);
  --glow-beta:0 0 20px rgba(74,163,255,0.4);
  --glow-gamma:0 0 20px rgba(255,210,74,0.4);
  --glow-delta:0 0 20px rgba(67,224,122,0.4);
}
*{box-sizing:border-box}
html,body{
  margin:0;
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Hiragino Sans","Noto Sans JP","Yu Gothic",Meiryo,sans-serif;
  background:
    radial-gradient(900px 600px at 10% 10%, rgba(255,93,179,0.2), transparent 60%),
    radial-gradient(820px 560px at 90% 0%, rgba(74,163,255,0.18), transparent 55%),
    radial-gradient(900px 650px at 50% 105%, rgba(67,224,122,0.12), transparent 55%),
    linear-gradient(180deg, var(--bg-dark), var(--bg-medium));
  color:var(--text-primary);
  letter-spacing:.01em;
  min-height:100vh;
}
.wrap{max-width:1180px;margin:0 auto;padding:14px;display:grid;gap:12px}

.topbar{
  display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
  padding:14px 16px;border:1px solid var(--border-dark);border-radius:18px;
  background:var(--panel-dark);backdrop-filter: blur(20px);
  box-shadow:var(--shadow-dark);
}
.brand{display:flex;align-items:center;gap:10px}
.logo{
  width:36px;height:36px;border-radius:14px;
  background:linear-gradient(135deg,var(--hi),var(--hi2));
  box-shadow:0 14px 30px rgba(255,79,216,.18);
}
.brand h1{margin:0;font-size:14px;font-weight:1000;letter-spacing:.08em;color:var(--text-primary)}
.actions{display:flex;gap:8px;flex-wrap:wrap}

.btn{
  padding:10px 12px;border:1px solid var(--border-dark);border-radius:14px;
  background:var(--panel-light);color:var(--text-primary);
  font-weight:1000;cursor:pointer;min-height:42px;user-select:none;
  box-shadow:0 8px 24px rgba(0,0,0,0.2);
  transition:all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}
.btn:hover{
  transform:translateY(-2px);
  box-shadow:var(--glow-alpha), 0 12px 32px rgba(0,0,0,0.3);
  border-color:var(--q-alpha);
}
.btn:active{transform:translateY(0);scale:0.98}
.btn.primary{
  border-color:transparent;
  background:linear-gradient(135deg,var(--q-alpha),var(--q-beta));
  color:#fff;
  box-shadow:var(--glow-alpha), 0 12px 32px rgba(0,0,0,0.3);
}
.btn.primary:hover{
  box-shadow:var(--glow-beta), 0 16px 40px rgba(0,0,0,0.4);
  transform:translateY(-3px);
}
.btn[disabled]{opacity:.45;cursor:not-allowed;transform:none}

.grid{display:grid;gap:12px}
@media(min-width:940px){
  .grid{grid-template-columns: 1.25fr .75fr;}
}

.card{
  border:1px solid var(--border-dark);
  border-radius:18px;
  background:var(--panel-dark);
  backdrop-filter: blur(20px);
  box-shadow:var(--shadow-dark);
  overflow:hidden;
}
.body{padding:16px;display:grid;gap:12px}

.row{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap}
.bar{
  flex:1;min-width:220px;height:12px;border-radius:999px;overflow:hidden;
  border:1px solid var(--border-dark);background:var(--panel-light)
}
.bar>div{height:100%;width:0%;background:linear-gradient(90deg,var(--q-alpha),var(--q-beta))}
.badge{
  display:inline-flex;align-items:center;gap:8px;
  padding:8px 12px;border-radius:999px;border:1px solid var(--border-dark);
  background:var(--panel-light);font-size:12px;color:var(--text-primary);font-weight:1000;
  box-shadow:0 8px 24px rgba(0,0,0,0.15);
}

.qbox{
  border:1px solid var(--border-dark);
  border-radius:16px;
  padding:16px;
  background:var(--panel-light);
  box-shadow:0 8px 24px rgba(0,0,0,0.15);
}
.qno{font-weight:1200;font-size:12px;color:var(--text-muted);letter-spacing:.12em}
.qtext{font-size:16px;line-height:1.85;margin:10px 0 14px;color:var(--text-primary)}

.scale5,.scale3{display:grid;gap:10px}
@media(min-width:740px){ .scale5{grid-template-columns:repeat(5,1fr)} .scale3{grid-template-columns:repeat(3,1fr)} }

.opt{
  border:1px solid var(--border-dark); border-radius:16px; padding:12px;
  background:var(--panel-light); cursor:pointer; user-select:none;
  display:flex; align-items:center; gap:10px; min-height:56px;
  transition:.2s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow:0 8px 20px rgba(0,0,0,0.1);
}
.opt:hover{transform:translateY(-2px);box-shadow:var(--glow-alpha);border-color:var(--q-alpha)}
.dot{
  width:16px;height:16px;border-radius:999px;border:2px solid var(--border-dark);
  display:inline-block;position:relative;flex:0 0 auto
}
.opt.sel{
  border-color:var(--q-alpha);
  box-shadow:var(--glow-alpha);
}
.opt.sel .dot{border-color:var(--q-alpha)}
.opt.sel .dot::after{
  content:"";position:absolute;inset:3px;border-radius:999px;background:var(--q-alpha)
}
.lab{font-size:13px;color:var(--text-primary);font-weight:1100}
.subv{font-size:11px;color:var(--text-secondary);margin-left:auto;font-weight:1100}

.controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:flex-end}

.kv{
  border:1px solid var(--border-dark);
  border-radius:16px;
  background:var(--panel-light);
  padding:12px;
  box-shadow:0 8px 24px rgba(0,0,0,0.15);
}
.kv .t{font-size:12px;color:var(--text-secondary);letter-spacing:.10em}

.rankItem{
  display:flex;align-items:center;justify-content:space-between;gap:10px;
  padding:10px 12px;border-radius:16px;border:1px solid var(--border-dark);
  background:var(--panel-light);
  box-shadow:0 8px 20px rgba(0,0,0,0.1);
}
.rankItem b{font-weight:1200}
.pct{font-weight:1200}
.hr{height:1px;background:var(--border-dark);margin:8px 0}
.small{font-size:12px;color:var(--text-secondary);line-height:1.7}
.hidden{display:none !important;}
.pill{
  display:inline-flex;align-items:center;gap:8px;
  border:1px solid var(--border-dark);
  background:var(--panel-light);
  padding:6px 10px;border-radius:999px;
  font-size:12px;color:var(--text-primary);font-weight:1100;
}

/* Visualization grid for results */
.vizGrid{display:grid;gap:8px}
.vizRow{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
.vizRow b{min-width:200px;display:inline-block;font-weight:800;color:var(--text-primary)}
.vizBar{flex:1;height:10px;border-radius:999px;background:var(--panel-light);overflow:hidden;border:1px solid var(--border-dark)}
.vizBar i{display:block;height:100%;background:linear-gradient(90deg,var(--q-alpha),var(--q-beta));width:0;transition:width 900ms cubic-bezier(0.25, 0.46, 0.45, 0.94)}
.vizBarSplit div[data-w]{transition:width 900ms cubic-bezier(0.25, 0.46, 0.45, 0.94)}
@media (prefers-reduced-motion: reduce) {
  .vizBar i, .vizBarSplit div[data-w] { transition: none; }
}
.vizPct{width:56px;text-align:right;font-weight:800;color:var(--text-secondary)}

/* Split bar for signed element scores */
.vizBarSplit{
  flex:1;height:14px;border-radius:8px;background:var(--panel-light);overflow:hidden;border:1px solid var(--border-dark);display:flex;align-items:center;
  position:relative;
}
.vizBarSplit .neg{height:8px;background:linear-gradient(90deg,var(--q-alpha),var(--q-gamma));border-radius:6px 0 0 6px;}
.vizBarSplit .pos{height:8px;background:linear-gradient(90deg,var(--q-beta),var(--q-delta));border-radius:0 6px 6px 0;}
.vizBarSplit .centerLine{position:absolute;left:50%;top:0;bottom:0;width:1px;background:var(--border-dark);transform:translateX(-0.5px)}
.vizBarSplit .barWrap{display:flex;width:100%;justify-content:center;align-items:center;padding:3px}

/* small adjustments for result cards */
.qbox .small b{font-weight:900}

/* hide any catMapping completely */
#catMapping{display:none !important;}

/* small unobtrusive export link/button */
.exportLink{
  background:transparent;border:0;color:var(--text-secondary);font-size:12px;padding:4px 6px;cursor:pointer;text-decoration:underline;
  border-radius:6px;
  transition:color 0.2s;
}
.exportLink:hover{color:var(--q-alpha)}

/* --------------------------
   Result Screen - Dark Wallet Style with Quadra Colors
   -------------------------- */
.resultHero{
  position:relative;
  border-radius:24px;
  padding:32px;
  background:
    linear-gradient(135deg, rgba(255,93,179,0.15), rgba(74,163,255,0.1)),
    linear-gradient(45deg, rgba(255,210,74,0.08), transparent),
    var(--panel-dark);
  backdrop-filter: blur(20px);
  border:1px solid var(--border-dark);
  box-shadow:
    var(--shadow-dark),
    var(--shadow-neon),
    inset 0 1px 0 rgba(255,255,255,0.1);
  overflow:hidden;
}

.resultHero::before{
  content:"";
  position:absolute;
  inset:0;
  border-radius:24px;
  padding:1px;
  background:linear-gradient(135deg, var(--q-alpha), transparent, var(--q-beta), transparent, var(--q-gamma), transparent, var(--q-delta));
  opacity:0.2;
  mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
  mask-composite:exclude;
  pointer-events:none;
  animation:borderRotate 8s linear infinite;
}

@keyframes borderRotate{
  0%{transform:rotate(0deg);}
  100%{transform:rotate(360deg);}
}

.resultHero__bg{
  position:absolute;
  inset:0;
  border-radius:24px;
  background:
    radial-gradient(circle at 20% 20%, rgba(255,93,179,0.4) 0%, transparent 50%),
    radial-gradient(circle at 80% 80%, rgba(74,163,255,0.35) 0%, transparent 50%),
    radial-gradient(circle at 50% 50%, rgba(255,210,74,0.2) 0%, transparent 60%),
    radial-gradient(circle at 30% 70%, rgba(67,224,122,0.15) 0%, transparent 50%);
  opacity:0.7;
  animation:bgFloat 6s ease-in-out infinite alternate;
}

@keyframes bgFloat{
  0%{transform:translate(0, 0) scale(1);}
  100%{transform:translate(-10px, -10px) scale(1.05);}
}

.resultHero__content{
  position:relative;
  z-index:1;
}

.resultHeadline{
  font-size:32px;
  font-weight:1400;
  line-height:1.2;
  margin:0 0 8px 0;
  background:linear-gradient(135deg, var(--q-alpha), var(--q-beta), var(--q-gamma));
  background-clip:text;
  -webkit-background-clip:text;
  -webkit-text-fill-color:transparent;
  letter-spacing:0.02em;
  text-shadow:0 0 30px rgba(255,93,179,0.3);
}

.resultSubline{
  font-size:16px;
  color:var(--text-secondary);
  font-weight:600;
  margin:0;
}

.top3Grid{
  display:grid;
  gap:20px;
  margin-top:32px;
  grid-template-columns:1fr;
}

@media(min-width:768px){
  .top3Grid{
    grid-template-columns:2fr 1fr;
  }
  /* Explicit grid positioning to ensure 1st place is always primary */
  .top3Grid .topCard:nth-child(1){
    grid-row:1 / span 2;
    grid-column:1;
  }
  .top3Grid .topCard:nth-child(2){
    grid-row:1;
    grid-column:2;
  }
  .top3Grid .topCard:nth-child(3){
    grid-row:2;
    grid-column:2;
  }
}

.topCard{
  border-radius:20px;
  padding:24px;
  background:var(--panel-light);
  backdrop-filter: blur(16px);
  border:1px solid var(--border-dark);
  box-shadow:
    0 12px 24px rgba(0,0,0,0.2),
    0 6px 12px rgba(255,93,179,0.1);
  transition:all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  position:relative;
  overflow:hidden;
}

.topCard::before{
  content:"";
  position:absolute;
  top:0;
  left:-100%;
  width:100%;
  height:100%;
  background:linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
  transition:left 0.5s;
}

.topCard:hover::before{
  left:100%;
}

.topCard:hover{
  transform:translateY(-6px) rotateX(2deg);
  box-shadow:
    0 25px 50px rgba(0,0,0,0.3),
    var(--glow-alpha);
}

.topCard--primary{
  background:
    linear-gradient(135deg, rgba(255,93,179,0.1), rgba(74,163,255,0.08)),
    var(--panel-light);
  border:1px solid rgba(255,93,179,0.2);
  grid-column:1 / -1;
}

.topCard--primary:hover{
  box-shadow:
    0 30px 60px rgba(0,0,0,0.4),
    var(--glow-beta),
    var(--glow-alpha);
}

/* Quadra-specific card colors */
.topCard[data-quadra="alpha"]{
  border-color:var(--q-alpha);
  box-shadow:
    0 12px 24px rgba(0,0,0,0.2),
    0 6px 12px rgba(255,93,179,0.2);
}
.topCard[data-quadra="alpha"]:hover{
  box-shadow:
    0 25px 50px rgba(0,0,0,0.3),
    var(--glow-alpha);
}

.topCard[data-quadra="beta"]{
  border-color:var(--q-beta);
  box-shadow:
    0 12px 24px rgba(0,0,0,0.2),
    0 6px 12px rgba(74,163,255,0.2);
}
.topCard[data-quadra="beta"]:hover{
  box-shadow:
    0 25px 50px rgba(0,0,0,0.3),
    var(--glow-beta);
}

.topCard[data-quadra="gamma"]{
  border-color:var(--q-gamma);
  box-shadow:
    0 12px 24px rgba(0,0,0,0.2),
    0 6px 12px rgba(255,210,74,0.2);
}
.topCard[data-quadra="gamma"]:hover{
  box-shadow:
    0 25px 50px rgba(0,0,0,0.3),
    var(--glow-gamma);
}

.topCard[data-quadra="delta"]{
  border-color:var(--q-delta);
  box-shadow:
    0 12px 24px rgba(0,0,0,0.2),
    0 6px 12px rgba(67,224,122,0.2);
}
.topCard[data-quadra="delta"]:hover{
  box-shadow:
    0 25px 50px rgba(0,0,0,0.3),
    var(--glow-delta);
}

.topCard__header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
  margin-bottom:16px;
}

.topCard__rank{
  display:flex;
  align-items:center;
  gap:8px;
  font-size:14px;
  font-weight:800;
  color:var(--text-secondary);
  text-transform:uppercase;
  letter-spacing:0.08em;
}

.rankBadge{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:32px;
  height:32px;
  border-radius:50%;
  background:linear-gradient(135deg, var(--q-alpha), var(--q-beta));
  color:#fff;
  font-size:14px;
  font-weight:1200;
  box-shadow:0 4px 12px rgba(255,93,179,0.4);
}

.topCard__type{
  font-size:24px;
  font-weight:1200;
  color:var(--text-primary);
  margin:0;
  text-shadow:0 0 20px currentColor;
}

.topCard--primary .topCard__type{
  font-size:28px;
}

.topCard__meta{
  display:flex;
  align-items:center;
  gap:12px;
  margin-top:8px;
}

.quadraBadge{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:6px 12px;
  border-radius:999px;
  background:var(--panel-light);
  border:1px solid var(--border-dark);
  font-size:12px;
  font-weight:800;
  color:var(--text-secondary);
  transition:all 0.2s;
}

.quadraSymbol{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:20px;
  height:20px;
  border-radius:50%;
  color:#fff;
  font-size:10px;
  font-weight:1200;
  text-shadow:0 0 10px currentColor;
}

/* Quadra symbol colors */
.quadraBadge[data-quadra="alpha"] .quadraSymbol{
  background:linear-gradient(135deg, var(--q-alpha), var(--q-beta));
  box-shadow:var(--glow-alpha);
}
.quadraBadge[data-quadra="beta"] .quadraSymbol{
  background:linear-gradient(135deg, var(--q-beta), var(--q-gamma));
  box-shadow:var(--glow-beta);
}
.quadraBadge[data-quadra="gamma"] .quadraSymbol{
  background:linear-gradient(135deg, var(--q-gamma), var(--q-delta));
  box-shadow:var(--glow-gamma);
}
.quadraBadge[data-quadra="delta"] .quadraSymbol{
  background:linear-gradient(135deg, var(--q-delta), var(--q-alpha));
  box-shadow:var(--glow-delta);
}

.percentageDisplay{
  display:flex;
  align-items:center;
  gap:8px;
  font-size:20px;
  font-weight:1200;
  color:var(--text-primary);
  text-shadow:0 0 10px currentColor;
}

.percentageBar{
  width:60px;
  height:6px;
  border-radius:999px;
  background:var(--panel-light);
  overflow:hidden;
  position:relative;
  border:1px solid var(--border-dark);
}

.percentageBar__fill{
  height:100%;
  border-radius:999px;
  transition:width 0.8s cubic-bezier(0.4, 0, 0.2, 1);
  box-shadow:0 0 10px currentColor;
}

/* Quadra-specific percentage bar colors */
.topCard[data-quadra="alpha"] .percentageBar__fill{
  background:linear-gradient(90deg, var(--q-alpha), var(--q-beta));
}
.topCard[data-quadra="beta"] .percentageBar__fill{
  background:linear-gradient(90deg, var(--q-beta), var(--q-gamma));
}
.topCard[data-quadra="gamma"] .percentageBar__fill{
  background:linear-gradient(90deg, var(--q-gamma), var(--q-delta));
}
.topCard[data-quadra="delta"] .percentageBar__fill{
  background:linear-gradient(90deg, var(--q-delta), var(--q-alpha));
}

.topCard__details{
  margin-top:20px;
  padding-top:16px;
  border-top:1px solid var(--border-dark);
}

.detailRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:16px;
  margin-bottom:8px;
  font-size:13px;
  line-height:1.6;
}

.detailLabel{
  font-weight:600;
  color:var(--text-secondary);
}

.detailValue{
  font-weight:800;
  color:var(--text-primary);
  text-shadow:0 0 8px currentColor;
}

.topCard__description{
  margin-top:16px;
  padding-top:16px;
  border-top:1px solid var(--border-dark);
  font-size:14px;
  line-height:1.8;
  color:var(--text-primary);
  font-weight:500;
}

.sparkLine{
  display:inline-flex;
  align-items:center;
  gap:2px;
  margin-left:8px;
}

.sparkDot{
  width:4px;
  height:4px;
  border-radius:50%;
  background:var(--text-secondary);
  opacity:0.3;
  transition:all 0.2s;
}

.sparkDot.active{
  opacity:1;
  background:var(--q-alpha);
  box-shadow:0 0 6px var(--q-alpha);
}

/* Animated background particles */
.topCard::after{
  content:"";
  position:absolute;
  width:2px;
  height:2px;
  background:var(--q-alpha);
  border-radius:50%;
  opacity:0;
  animation:particleFloat 4s ease-in-out infinite;
}

.topCard[data-quadra="beta"]::after{
  background:var(--q-beta);
}
.topCard[data-quadra="gamma"]::after{
  background:var(--q-gamma);
}
.topCard[data-quadra="delta"]::after{
  background:var(--q-delta);
}

.topCard:hover::after{
  opacity:0.6;
}

@keyframes particleFloat{
  0%, 100%{
    transform:translate(0, 0) scale(1);
    opacity:0;
  }
  25%{
    transform:translate(20px, -30px) scale(1.5);
    opacity:0.6;
  }
  50%{
    transform:translate(-10px, -50px) scale(0.8);
    opacity:0.3;
  }
  75%{
    transform:translate(30px, -20px) scale(1.2);
    opacity:0.8;
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  .resultHero::before,
  .resultHero__bg,
  .topCard::after,
  .topCard::before {
    animation: none;
  }
  
  .topCard:hover {
    transform: translateY(-4px);
  }
  
  .percentageBar__fill {
    transition: none;
  }
}

</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="brand">
      <div class="logo" aria-hidden="true"></div>
      <div>
        <h1>Socionics Typing v2.5 </h1>
      </div>
    </div>
    <div class="actions">
      <button class="btn" id="btnToggleLive">上位候補を表示</button>
      <button class="btn" id="btnRestartTop">最初から</button>
    </div>
  </div>

  <div class="grid">
    <!-- MAIN -->
    <div class="card">
      <div class="body" id="screenQuiz">
        <div class="row">
          <div class="bar" aria-label="progress"><div id="barFill"></div></div>
          <div class="badge"><b id="progText">0 / 60</b></div>
        </div>

        <div id="bootError" class="err hidden"></div>

        <div class="qbox">
          <div class="qno" id="qNo">Q1</div>
          <div class="qtext" id="qText">—</div>

          <div id="catMapping" class="small" style="opacity:.9"></div>

          <div class="scale5" id="scale5"></div>
          <div class="scale3" id="scale3" style="display:none"></div>

          <div class="controls" style="margin-top:12px">
            <button class="btn" id="btnBack" disabled>戻る</button>
            <button class="btn" id="btnSkip">わからない</button>
            <button class="btn primary" id="btnNext" disabled>次へ</button>
          </div>
        </div>
      </div>

      <div class="body" id="screenResult" style="display:none">
        <!-- Wallet Style Hero Card -->
        <div class="resultHero">
          <div class="resultHero__bg"></div>
          <div class="resultHero__content">
            <div style="display:flex;align-items:center;justify-content:space-between;gap:16px;flex-wrap:wrap">
              <div>
                <h1 class="resultHeadline" id="resHeadline">—</h1>
                <p class="resultSubline">あなたの推定タイプ</p>
              </div>
              <div style="text-align:right">
                <button id="btnSaveImage" type="button" class="btn primary" style="min-height:48px;padding:12px 20px;font-size:14px;font-weight:1200;">
                  結果画像を保存
                </button>
              </div>
            </div>
            <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:flex-end;margin-top:24px">
              <button class="btn primary" id="btnRestart">最初から</button>
            </div>
          </div>
        </div>

        <!-- 簡易ビジュアル（情報要素の価値寄り度・クアドラ割合） -->
        <div class="qbox">
          <div class="row">
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
              <span class="pill">詳細グラフ</span>
              <span class="small">（回答傾向を視覚化します）</span>
            </div>
          </div>
          <div class="hr"></div>
          <div style="display:grid;gap:14px">
            <div>
              <div style="font-weight:1200;margin-bottom:8px">情報要素（価値寄り度）</div>
              <div id="elementViz" class="vizGrid"></div>
            </div>
            <div>
              <div style="font-weight:1200;margin-bottom:8px">クアドラ割合（推定）</div>
              <div id="quadraViz" class="vizGrid"></div>
            </div>
          </div>
        </div>

        <div id="resCards" style="display:grid;gap:12px;margin-top:12px"></div>

        <!-- Feedback -->
        <div class="qbox" id="feedbackBox">
          <div class="row">
            <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap">
              <span class="pill">フィードバック</span>
              <span class="small">（1位タイプを前提に、回答傾向を要点化します）</span>
            </div>
            <button class="btn" id="btnToggleFeedback">開く</button>
          </div>
          <div class="hr"></div>
          <div id="feedbackContent" class="hidden">
            <div class="small" id="fbQuadra">—</div>
            <div style="display:grid;gap:10px;margin-top:10px">
              <div>
                <div style="font-weight:1200;margin-bottom:6px">価値（優先しやすい情報要素）</div>
                <div class="small" id="fbValues">—</div>
              </div>
              <div>
                <div style="font-weight:1200;margin-bottom:6px">回答から見えた強まり</div>
                <div class="small" id="fbStrong">—</div>
              </div>
              <div>
                <div style="font-weight:1200;margin-bottom:6px">1位タイプらしさとズレやすい点（要注意ポイント）</div>
                <div class="small" id="fbMismatch">—</div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <!-- SIDE -->
    <div class="card hidden" id="sideCard">
      <div class="body">
        <div class="kv">
          <div class="t">上位候補</div>
          <div id="topList" style="display:grid;gap:10px;margin-top:10px"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- html2canvas library for reliable DOM to canvas conversion -->
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

<script>
(() => {
  "use strict";
  /* --------------------------
     Core constants / models
     -------------------------- */
  const TYPES=["ILE","SEI","ESE","LII","EIE","LSI","SLE","IEI","SEE","ILI","LIE","ESI","LSE","EII","IEE","SLI"];
  const ELEMENTS=["Te","Ti","Fe","Fi","Ne","Ni","Se","Si"];

  const QUADRA={
    ILE:"Alpha", SEI:"Alpha", ESE:"Alpha", LII:"Alpha",
    EIE:"Beta",  LSI:"Beta",  SLE:"Beta",  IEI:"Beta",
    SEE:"Gamma", ILI:"Gamma", LIE:"Gamma", ESI:"Gamma",
    IEE:"Delta", SLI:"Delta", LSE:"Delta", EII:"Delta"
  };
  const QSYM={Alpha:"α",Beta:"β",Gamma:"γ",Delta:"Δ"};

  const MODEL={
    ILE:["Ne","Ti","Se","Fi","Si","Fe","Ni","Te"],
    SEI:["Si","Fe","Ni","Te","Ne","Ti","Se","Fi"],
    ESE:["Fe","Si","Te","Ni","Ti","Ne","Fi","Se"],
    LII:["Ti","Ne","Fi","Se","Fe","Si","Te","Ni"],
    EIE:["Fe","Ni","Te","Si","Ti","Se","Fi","Ne"],
    SLE:["Se","Ti","Ne","Fi","Ni","Fe","Si","Te"],
    LSI:["Ti","Se","Fi","Ne","Fe","Ni","Te","Si"],
    IEI:["Ni","Fe","Si","Te","Se","Ti","Ne","Fi"],
    SEE:["Se","Fi","Ne","Ti","Ni","Te","Si","Fe"],
    ILI:["Ni","Te","Si","Fe","Se","Fi","Ne","Ti"],
    LIE:["Te","Ni","Fe","Si","Fi","Se","Ti","Ne"],
    ESI:["Fi","Se","Ti","Ne","Te","Ni","Fe","Si"],
    SLI:["Si","Te","Ni","Fe","Ne","Fi","Se","Ti"],
    IEE:["Ne","Fi","Se","Ti","Si","Te","Ni","Fe"],
    LSE:["Te","Si","Fe","Ni","Fi","Ne","Ti","Se"],
    EII:["Fi","Ne","Ti","Se","Te","Si","Fe","Ni"]
  };

  const QUADRA_VALUES={
    Alpha:new Set(["Ne","Ti","Fe","Si"]),
    Beta :new Set(["Fe","Ni","Se","Ti"]),
    Gamma:new Set(["Fi","Te","Se","Ni"]),
    Delta:new Set(["Si","Te","Fi","Ne"])
  };

  const DICH = {
    E: new Set(["ILE","ESE","EIE","SLE","SEE","LIE","LSE","IEE"]),
    I: new Set(["LII","SEI","LSI","IEI","ESI","ILI","SLI","EII"]),
    S: new Set(["SEI","ESE","LSI","SLE","SEE","ESI","LSE","SLI"]),
    N: new Set(["ILE","LII","EIE","IEI","IEE","EII","LIE","ILI"]),
    T: new Set(["ILE","LII","LSI","SLE","LIE","LSE","ILI","SLI"]),
    F: new Set(["SEI","ESE","EIE","IEI","SEE","ESI","IEE","EII"]),
    J: new Set(["LII","ESE","EIE","LSI","ESI","LIE","LSE","EII"]),
    P: new Set(["ILE","SEI","SLE","IEI","SEE","ILI","SLI","IEE"])
  };

  const POS_W   = [1.00, 0.80, 0.25, 0.40, 0.25, 0.40, 0.20, 0.15];
  const VAL_SIGN = [+1, +1, -1, -1, +1, +1, -1, -1];

  /* --------------------------
     Utility math
     -------------------------- */
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const sigmoid=(x)=>1/(1+Math.exp(-x));
  function normalizeVec(obj){
    const s = Object.values(obj).reduce((a,b)=>a+b,0) || 1;
    const out={}; for(const k in obj) out[k]=obj[k]/s; return out;
  }
  function entropy(probs){
    let h=0;
    for(const p of Object.values(probs||{})){
      if(p<=0) continue;
      h -= p*Math.log(p);
    }
    return h;
  }
  const topN=(probs,n=3)=>Object.entries(probs).sort((a,b)=>b[1]-a[1]).slice(0,n);

  /* --------------------------
     Quadra detection helper
     -------------------------- */
  function getQuadra(type){
    if(!type || typeof type !== "string") return "alpha";
    const cleanType = type.trim().toUpperCase();
    
    const quadraMap = {
      "ILE":"alpha", "SEI":"alpha", "ESE":"alpha", "LII":"alpha",
      "EIE":"beta",  "LSI":"beta",  "SLE":"beta",  "IEI":"beta",
      "SEE":"gamma", "ILI":"gamma", "LIE":"gamma", "ESI":"gamma",
      "IEE":"delta", "SLI":"delta", "LSE":"delta", "EII":"delta"
    };
    
    return quadraMap[cleanType] || "alpha";
  }

  /* --------------------------
     QUESTIONS: id:1 replaced; id:45 removed
     NOTE: QUESTIONS.length now drives progress display and iteration.
     -------------------------- */
  const QUESTIONS = [
  {"id":1,"phase":1,"text":"集まりや飲み会の翌日は、一人で静かに回復する時間が必要になりやすいです。","axis":"EI","axisDir":"I","element":null,"dimension":"none","weight":1.2},
  {"id":2,"phase":1,"text":"仕事や課題で詰まったとき、誰かに話しながら整理する方です。","axis":"EI","axisDir":"E","element":null,"dimension":"none","weight":1.2},
  {"id":3,"phase":1,"text":"初対面の人が多い場では、自分から話しかける方です。","axis":"EI","axisDir":"E","element":null,"dimension":"none","weight":1.2},
  {"id":4,"phase":1,"text":"忙しい日は、相談や打ち合わせを入れて進めたい方です。","axis":"EI","axisDir":"E","element":null,"dimension":"none","weight":1.2},
  {"id":5,"phase":1,"text":"数か月続くチーム作業で、人と関わり続けるのはあまり負担になりません。","axis":"EI","axisDir":"E","element":null,"dimension":"none","weight":1.2},

  {"id":6,"phase":1,"text":"説明するときは、実際にあった話や具体例から話すことが多いです。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.2},
  {"id":7,"phase":1,"text":"旅行や企画を考えるとき、体験の雰囲気より「何をするか」を先に決めます。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.2},
  {"id":8,"phase":1,"text":"人の話を聞くとき、「それが何を示すか」より「何が起きたか」が印象に残ります。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.2},
  {"id":9,"phase":1,"text":"仕事の指示は、狙いより手順を細かく伝える方です。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.2},
  {"id":10,"phase":1,"text":"アイデアは、面白さよりも「実際に使えるか」で評価しがちです。","axis":"SN","axisDir":"S","element":null,"dimension":"none","weight":1.2},

  {"id":11,"phase":1,"text":"意見が割れたら、納得感より数字や根拠で決めたいです。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.2},
  {"id":12,"phase":1,"text":"人を評価するとき、人柄より成果・スキルを重視します。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.2},
  {"id":13,"phase":1,"text":"注意するとき、言い方より正しさを優先します。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.5},
  {"id":14,"phase":1,"text":"議論中は、その場の雰囲気より話が論理的かが気になります。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.2},
  {"id":15,"phase":1,"text":"チームでは、関係性より役割と成果を重視します。","axis":"TF","axisDir":"T","element":null,"dimension":"none","weight":1.2},

  {"id":16,"phase":1,"text":"締切前に迷ったとき、多少荒くても出す方です。","axis":"JP","axisDir":"P","element":null,"dimension":"none","weight":1.2},
  {"id":17,"phase":1,"text":"トラブルが起きたときは、まず状況を整理して「どう対処するか」を決めてから動きたいです。","axis":"JP","axisDir":"J","element":null,"dimension":"none","weight":1.2},
  {"id":18,"phase":1,"text":"新しいことに取り組むとき、細かく決めてからよりも、走りながら考える方が合っています。","axis":"JP","axisDir":"P","element":null,"dimension":"none","weight":1.2},
  {"id":19,"phase":1,"text":"仕事では、やるべきことを先に決めて、計画通りに進めたい方です。","axis":"JP","axisDir":"J","element":null,"dimension":"none","weight":1.2},
  {"id":20,"phase":1,"text":"会話や打ち合わせでは、結論を急がず、流れの中で自然に決まっていく方が楽です。","axis":"JP","axisDir":"P","element":null,"dimension":"none","weight":1.2},

  {"id":21,"phase":2,"text":"話し合いで案が1つに絞られていくと、「他の案も考えたい」と物足りなく感じます。","axis":null,"axisDir":null,"element":"Ne","dimension":"none","weight":1.0},
  {"id":22,"phase":2,"text":"新しい話を聞くと、「もっと別の形もありそう」と自然に考えます。","axis":null,"axisDir":null,"element":"Ne","dimension":"none","weight":1.0},
  {"id":23,"phase":2,"text":"選択肢が少ない状況は、少し窮屈に感じます。","axis":null,"axisDir":null,"element":"Ne","dimension":"none","weight":1.0},

  {"id":24,"phase":2,"text":"出来事を見るとき、「この先どうなりそうか」を考えるのが自然です。","axis":null,"axisDir":null,"element":"Ni","dimension":"none","weight":1.0},
  {"id":25,"phase":2,"text":"決断するとき、「今かどうか」というタイミングを重視します。","axis":null,"axisDir":null,"element":"Ni","dimension":"none","weight":1.0},
  {"id":26,"phase":2,"text":"短期の成果より、長期の方向性の方が気になります。","axis":null,"axisDir":null,"element":"Ni","dimension":"none","weight":1.0},

  {"id":27,"phase":2,"text":"迷っている場面では、誰かが決めて前に進めると安心します。","axis":null,"axisDir":null,"element":"Se","dimension":"none","weight":1.0},
  {"id":28,"phase":2,"text":"必要なら、少し強く言ってでも進めたいと思います。","axis":null,"axisDir":null,"element":"Se","dimension":"none","weight":1.0},
  {"id":29,"phase":2,"text":"グループワークにおいて、主導権を握って動かす方が落ち着きます。","axis":null,"axisDir":null,"element":"Se","dimension":"none","weight":1.0},

  {"id":30,"phase":2,"text":"環境や体調が整っていると、気持ちも安定します。","axis":null,"axisDir":null,"element":"Si","dimension":"none","weight":1.0},
  {"id":31,"phase":2,"text":"無理のないペースで進められると安心します。","axis":null,"axisDir":null,"element":"Si","dimension":"none","weight":1.0},
  {"id":32,"phase":2,"text":"小さな不快が続くと、集中しにくくなります。","axis":null,"axisDir":null,"element":"Si","dimension":"none","weight":1.0},

  {"id":33,"phase":2,"text":"言葉やルールの意味が曖昧だと、まずはっきりさせたくなります。","axis":null,"axisDir":null,"element":"Ti","dimension":"none","weight":1.0},
  {"id":34,"phase":2,"text":"話を聞くとき、筋が通っているかが気になります。","axis":null,"axisDir":null,"element":"Ti","dimension":"none","weight":1.0},
  {"id":35,"phase":2,"text":"分類や整理ができると、頭がすっきりします。","axis":null,"axisDir":null,"element":"Ti","dimension":"none","weight":1.0},

  {"id":36,"phase":2,"text":"話が長くなると、「結局どうすればいいのか」を知りたくなります。","axis":null,"axisDir":null,"element":"Te","dimension":"none","weight":1.0},
  {"id":37,"phase":2,"text":"実績や数字があると、安心して判断できます。","axis":null,"axisDir":null,"element":"Te","dimension":"none","weight":1.0},
  {"id":38,"phase":2,"text":"成果につながらない作業は、早めに切り替えたいです。","axis":null,"axisDir":null,"element":"Te","dimension":"none","weight":1.0},

  {"id":39,"phase":2,"text":"場が静かすぎると、自分から少し動かしたくなります。","axis":null,"axisDir":null,"element":"Fe","dimension":"none","weight":1.0},
  {"id":40,"phase":2,"text":"感情を言葉にして共有できると、やりやすくなります。","axis":null,"axisDir":null,"element":"Fe","dimension":"none","weight":1.0},
  {"id":41,"phase":2,"text":"雰囲気が重いと、変えたくなります。","axis":null,"axisDir":null,"element":"Fe","dimension":"none","weight":1.0},

  {"id":42,"phase":2,"text":"人を見るとき、能力より誠実さが気になります。","axis":null,"axisDir":null,"element":"Fi","dimension":"none","weight":1.0},
  {"id":43,"phase":2,"text":"一対一において距離感が合わないと、居心地が悪くなります。","axis":null,"axisDir":null,"element":"Fi","dimension":"none","weight":1.0},
  {"id":44,"phase":2,"text":"友人に求める一番の条件は、約束や道理を守る人です。","axis":null,"axisDir":null,"element":"Fi","dimension":"none","weight":1.0},
  {"id":45,"phase":2,"text":"好意や信頼を向ける相手は、かなりはっきりと選んでいます。","axis":null,"axisDir":null,"element":"Fi","dimension":"none","weight":1.0},

  {"id":46,"phase":3,"text":"話し合いで案が1つに絞られていくと、「他の案も考えたい」と物足りなく感じます。","axis":"TF","axisDir":"T","element":"Ti","dimension":"unconscious","weight":0.8},
  {"id":47,"phase":3,"text":"場の雰囲気が重いとき、自然と「空気を和らげる行動」をしています。","axis":"TF","axisDir":"F","element":"Fe","dimension":"unconscious","weight":0.8},
  {"id":48,"phase":3,"text":"迷っている人を見ると、つい「決断を後押しする言葉や行動」を取ってしまいます。","axis":"EI","axisDir":"E","element":"Se","dimension":"unconscious","weight":0.8},
  {"id":49,"phase":3,"text":"初めての作業や役割でも、「どう動けばいいか」はあまり迷いません。","axis":null,"axisDir":null,"element":"Te","dimension":"unconscious","weight":0.8},
  {"id":50,"phase":3,"text":"人の話を聞くとき、内容よりも「流れ」や「タイミング」が先に気になります。","axis":"SN","axisDir":"N","element":"Ni","dimension":"unconscious","weight":0.8},

  {"id":51,"phase":3,"text":"体調や気分が良くない日でも、「いつも通りできる作業や判断」は大きく崩れません。","axis":null,"axisDir":null,"element":"Si","dimension":"stable","weight":0.8},
  {"id":52,"phase":3,"text":"職場や環境が変わっても、自分のやり方や考え方はあまり変わりません。","axis":null,"axisDir":null,"element":"Ti","dimension":"stable","weight":0.8},
  {"id":53,"phase":3,"text":"失敗したあとも、ガラッと手順を変えずだいたい同じやり方で対応します。","axis":null,"axisDir":null,"element":"Te","dimension":"stable","weight":0.8},
  {"id":54,"phase":3,"text":"忙しいときほど、自然と「自分の決まった動き方」で行動しています。","axis":null,"axisDir":null,"element":"Se","dimension":"stable","weight":0.8},
  {"id":55,"phase":3,"text":"状況が変わっても、同じ基準や考え方で判断しています。","axis":"TF","axisDir":"T","element":"Ti","dimension":"stable","weight":0.8},


  {"id":56,"phase":3,"text":"物事の考え方や発想の仕方について、「どういう視点で見ているか」を人に説明できます。","axis":"SN","axisDir":"N","element":"Ne","dimension":"reproducible","weight":0.8},
  {"id":57,"phase":3,"text":"話し合いで意見を出すとき、「どんな流れや意味を見てそう考えたか」を言葉で説明できます。","axis":"SN","axisDir":"N","element":"Ni","dimension":"reproducible","weight":0.8},
  {"id":58,"phase":3,"text":"周りから、「その発想どこから来たの？」と考え方や視点について聞かれることがあります。","axis":null,"axisDir":null,"element":"Ne","dimension":"reproducible","weight":0.8},
  {"id":59,"phase":3,"text":"自分の中で、「物事の捉え方」「発想の広げ方」に一定の型があります。","axis":"SN","axisDir":"N","element":"Ne","dimension":"reproducible","weight":0.8},
  {"id":60,"phase":3,"text":"誰かに考え方を教えるとき、出来事の意味や流れから説明することが多いです。","axis":"SN","axisDir":"N","element":"Ni","dimension":"reproducible","weight":0.8}

  ];

  /* --------------------------
     SCALE mapping (5-point)
     -------------------------- */
  const SCALE5=[
    {label:"そう思う", v:+2, c:0},
    {label:"部分的にそう思う", v:+1, c:1},
    {label:"中立", v:0, c:2},
    {label:"あまりそう思わない", v:-1, c:3},
    {label:"全くそう思わない", v:-2, c:4},
  ];

  /* --------------------------
     State
     -------------------------- */
  const state = {
    step: 0,
    asked: QUESTIONS.map((q,i)=>i),
    answers: [],
    posterior: Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length])),
    quadra: {Alpha:0.25,Beta:0.25,Gamma:0.25,Delta:0.25},
    axisScores: {E:0,I:0,S:0,N:0,T:0,F:0,J:0,P:0},
    elementScores: Object.fromEntries(ELEMENTS.map(e=>[e,0])),
    dimensionScores: {},
    respStats:{n:0, mean:0, m2:0, neutral:0, extreme:0},
    historyTop1:[],
    historyTop1Pct:[],
    historyGap:[],
    history: [],
    isAdvancing:false,
    livePinned:false
  };

  /* --------------------------
     UI elems
     -------------------------- */
  const elBarFill=document.getElementById("barFill");
  const elProg=document.getElementById("progText");
  const elQNo=document.getElementById("qNo");
  const elQText=document.getElementById("qText");
  const elScale5=document.getElementById("scale5");
  const elScale3=document.getElementById("scale3");
  const btnBack=document.getElementById("btnBack");
  const btnSkip=document.getElementById("btnSkip");
  const btnNext=document.getElementById("btnNext");
  const screenQuiz=document.getElementById("screenQuiz");
  const screenResult=document.getElementById("screenResult");
  const topList=document.getElementById("topList");
  const sideCard=document.getElementById("sideCard");
  const btnToggleLive=document.getElementById("btnToggleLive");

  function setProgress(){ elProg.textContent = `${state.step} / ${QUESTIONS.length}`; elBarFill.style.width = `${clamp(state.step/QUESTIONS.length,0,1)*100}%`; }

  /* --------------------------
     Existing helpers reused: stabilizePosterior, etc.
     (kept from prior implementation)
     -------------------------- */
  function sumSet(posterior, set){
    let s=0; for(const t of set) s += (posterior[t]||0);
    return s;
  }
  function factorizedFromDich(p){
    const pE = sumSet(p, DICH.E);
    const pS = sumSet(p, DICH.S);
    const pT = sumSet(p, DICH.T);
    const pJ = sumSet(p, DICH.J);
    const w = {};
    for(const t of TYPES){
      const e = DICH.E.has(t) ? pE : (1-pE);
      const s = DICH.S.has(t) ? pS : (1-pS);
      const tt= DICH.T.has(t) ? pT : (1-pT);
      const j = DICH.J.has(t) ? pJ : (1-pJ);
      w[t] = Math.max(1e-12, e*s*tt*j);
    }
    return normalizeVec(w);
  }
  function applyAxisSoftElimination(p, step){
    if(step < 8) return p;
    const pE = sumSet(p, DICH.E);
    const pS = sumSet(p, DICH.S);
    const pT = sumSet(p, DICH.T);
    const confE = Math.abs(pE - 0.5) * 2;
    const confS = Math.abs(pS - 0.5) * 2;
    const confT = Math.abs(pT - 0.5) * 2;
    const phase = step < 18 ? 0.55 : step < 30 ? 0.75 : 1.0;
    const confStart = 0.55;
    const strengthMax = 0.55;
    function axisPenalty(conf){
      if(conf <= confStart) return 1.0;
      const x = (conf - confStart) / (1 - confStart);
      const strength = Math.max(0, Math.min(1, x)) * strengthMax * phase;
      return Math.exp(-strength);
    }
    const penE = axisPenalty(confE);
    const penS = axisPenalty(confS);
    const penT = axisPenalty(confT);
    const out = {...p};
    for(const t of TYPES){
      let m = 1.0;
      if(pE >= 0.5 && DICH.I.has(t)) m *= penE;
      if(pE <  0.5 && DICH.E.has(t)) m *= penE;
      if(pS >= 0.5 && DICH.N.has(t)) m *= penS;
      if(pS <  0.5 && DICH.S.has(t)) m *= penS;
      if(pT >= 0.5 && DICH.F.has(t)) m *= penT;
      if(pT <  0.5 && DICH.T.has(t)) m *= penT;
      out[t] = (out[t]||0) * m;
    }
    return normalizeVec(out);
  }
  function getStabilizeLam(step){ return step < 20 ? 0.30 : step < 40 ? 0.20 : 0.22; }
  function stabilizePosterior(posterior, step){
    const lam = getStabilizeLam(step);
    const w = factorizedFromDich(posterior);
    const mixed = {};
    for(const t of TYPES) mixed[t] = (1-lam)*(posterior[t]||0) + lam*(w[t]||0);
    const normed = normalizeVec(mixed);
    const suppressed = applyAxisSoftElimination(normed, step);
    return normalizeVec(suppressed);
  }

  /* --------------------------
     computeQuadraFromPosterior + sharpening utilities
     -------------------------- */
  function computeQuadraFromPosterior(posterior){
    const quadra = {Alpha:0,Beta:0,Gamma:0,Delta:0};
    for(const t of TYPES){
      const q = QUADRA[t];
      quadra[q] += (posterior[t] || 0);
    }
    const s = quadra.Alpha + quadra.Beta + quadra.Gamma + quadra.Delta || 1;
    quadra.Alpha /= s; quadra.Beta /= s; quadra.Gamma /= s; quadra.Delta /= s;
    return quadra;
  }
  function sharpenDistribution(dist, k){
    const powered = {};
    for(const key of Object.keys(dist)){
      powered[key] = Math.pow(Math.max(1e-12, dist[key]||0), k);
    }
    return normalizeVec(powered);
  }
  function sharpenPosterior(posterior, k){
    const out = {};
    for(const t of TYPES) out[t] = Math.pow(Math.max(1e-12, posterior[t]||0), k);
    return normalizeVec(out);
  }
  function getSharpenK(step){
    const base = 1.0 + 1.5 * (step / (QUESTIONS.length - 1));
    return clamp(base, 1.0, 2.5);
  }
  function top1Prob(posterior){
    let best = 0;
    for(const v of Object.values(posterior)) if(v > best) best = v;
    return best || 0;
  }

  /* --------------------------
     Scoring and posterior recomputation (kept intact)
     -------------------------- */
  function updateRespStatsLikert(raw){
    const s=state.respStats;
    s.n+=1;
    const delta=raw-s.mean;
    s.mean+=delta/s.n;
    const delta2=raw-s.mean;
    s.m2+=delta*delta2;
    if(raw===0) s.neutral+=1;
    if(Math.abs(raw)===2) s.extreme+=1;
  }
  function stdev(){ const s=state.respStats; if(s.n<8) return 1.0; const v=s.m2/(s.n-1); return clamp(Math.sqrt(v), 0.55, 1.55); }
  function temperature(){ const s=state.respStats; const sd=stdev(); const neutralRate = s.n>0 ? (s.neutral/s.n) : 0; const extremeRate = s.n>0 ? (s.extreme/s.n) : 0; let T=1.0; if(neutralRate>0.48) T+=0.18; if(extremeRate>0.62) T+=0.12; if(sd<0.78) T+=0.12; if(sd>1.22) T+=0.12; return clamp(T, 0.85, 1.65); }
  const tempAdjustLike=(like)=>Math.pow(Math.max(1e-12, like), 1.0/temperature());

  function recomputePosteriorFromScores(stepForStabilize){
    const valE = (state.axisScores.E || 0) - (state.axisScores.I || 0);
    const valS = (state.axisScores.S || 0) - (state.axisScores.N || 0);
    const valT = (state.axisScores.T || 0) - (state.axisScores.F || 0);
    const valJ = (state.axisScores.J || 0) - (state.axisScores.P || 0);

    const pE = sigmoid(valE * 0.4);
    const pS = sigmoid(valS * 0.4);
    const pT = sigmoid(valT * 0.4);
    const pJ = sigmoid(valJ * 0.35);

    let maxAbsElem = 0;
    for(const e of ELEMENTS) maxAbsElem = Math.max(maxAbsElem, Math.abs(state.elementScores[e]||0));
    const elemScale = maxAbsElem > 0 ? (1 / maxAbsElem) : 1;

    const rawScores = {};
    const elementScoreNorm = {};
    for(const t of TYPES){
      let axisMatch = 0;
      axisMatch += (DICH.E.has(t) ? pE : (1-pE));
      axisMatch += (DICH.S.has(t) ? pS : (1-pS));
      axisMatch += (DICH.T.has(t) ? pT : (1-pT));
      axisMatch += (DICH.J.has(t) ? pJ : (1-pJ));
      axisMatch = axisMatch / 4;

      let dot = 0;
      for(const e in state.elementScores){
        const pos = MODEL[t].indexOf(e);
        if(pos >= 0){
          const w = POS_W[pos] * VAL_SIGN[pos];
          dot += (state.elementScores[e] || 0) * w;
        }
      }
      elementScoreNorm[t] = sigmoid(dot * 0.25);


      const wAxis = 0.48;
      const wElem = 0.48;
      const wPrior = 0.04;
      const combined = wAxis*axisMatch + wElem*(elementScoreNorm[t] || 0) + wPrior*(1/TYPES.length);
      rawScores[t] = Math.max(1e-12, combined);
    }

    const posteriorRaw = normalizeVec(rawScores);
    const stabilized = stabilizePosterior(posteriorRaw, stepForStabilize || state.step);
    state.posterior = stabilized;

    // compute quadra from posterior
    const qRaw = computeQuadraFromPosterior(state.posterior);

    // compute confidence and optionally mix toward top-type
    const conf = top1Prob(state.posterior);
    const topType = topN(state.posterior,1)[0] ? topN(state.posterior,1)[0][0] : null;
    const qTop = {Alpha:0,Beta:0,Gamma:0,Delta:0};
    if(topType) qTop[QUADRA[topType]] = 1;
    const w = clamp((conf - 0.35) / 0.65, 0, 1);
    const qMixed = {};
    for(const k of Object.keys(qRaw)){
      qMixed[k] = (1-w) * qRaw[k] + w * (qTop[k] || 0);
    }
    const qMixNorm = normalizeVec(qMixed);

    // sharpen quadra for display summary (k tuned later in renderViz as well)
    const kQ = 1 + 6 * conf;
    state.quadra = sharpenDistribution(qMixNorm, kQ);

    return stabilized;
  }

  /* --------------------------
     History logging
     -------------------------- */
  function gapTop2(probs){
    const t = topN(probs,2);
    if(t.length<2) return 1;
    return t[0][1]-t[1][1];
  }

  function recordHistory(optionalIdx){
    const idx = (typeof optionalIdx === "number") ? optionalIdx : state.step;
    const posterior = state.posterior || Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));
    const top = topN(posterior,3).map(([t,p])=>({type:t, prob:p}));
    while(top.length<3) top.push({type:"—", prob:0});
    const gap = gapTop2(posterior);
    const H = entropy(posterior);

    const pE = sumSet(posterior, DICH.E);
    const pI = sumSet(posterior, DICH.I);
    const pS = sumSet(posterior, DICH.S);
    const pN = sumSet(posterior, DICH.N);
    const pT = sumSet(posterior, DICH.T);
    const pF = sumSet(posterior, DICH.F);
    const pJ = sumSet(posterior, DICH.J);
    const pP = sumSet(posterior, DICH.P);

    const quadra = state.quadra || computeQuadraFromPosterior(posterior);

    const tempExp = getTemperingExponentForLogging(idx);
    const lam = getStabilizeLam(idx);

    // visual top progression uses sharpened display posterior
    const k = getSharpenK(idx);
    const displayP = sharpenPosterior(posterior, k);
    const topEntry = topN(displayP,1)[0];
    const topTypeName = topEntry ? topEntry[0] : "—";
    const topPct = topEntry ? displayP[topEntry[0]] * 100 : 0;

    state.historyTop1.push(topTypeName);
    state.historyTop1Pct.push(Math.round(topPct * 10) / 10);

    state.historyGap.push(gap);

    state.history.push({
      step: idx,
      top3: top,
      gap: gap,
      entropy: H,
      axes: {pE,pI,pS,pN,pT,pF,pJ,pP},
      quadra: quadra,
      tempExp: tempExp,
      stabilizeLam: lam,
      timestamp: Date.now()
    });
  }

  function getTemperingExponentForLogging(step){
    if(step < 12) return 0.85;
    if(step < 30) return 0.92;
    if(step < 45) return 0.90;
    return 0.86;
  }

  /* --------------------------
     Answer application (kept unchanged)
     -------------------------- */
  function applyResponse(ans, idx){
    const q = QUESTIONS[ans.id];
    if(!q) return;

    if(ans.skipped){
      recordHistory(idx);
      return;
    }

    updateRespStatsLikert(ans.raw);

    if(q.axis){
      const signed = ans.raw * q.weight;
      const dir = q.axisDir;
      if(q.axis === "EI"){
        if(dir === "E"){ state.axisScores.E += signed; state.axisScores.I -= signed; }
        else { state.axisScores.I += signed; state.axisScores.E -= signed; }
      }else if(q.axis === "SN"){
        if(dir === "S"){ state.axisScores.S += signed; state.axisScores.N -= signed; }
        else { state.axisScores.N += signed; state.axisScores.S -= signed; }
      }else if(q.axis === "TF" || q.axis === "FT"){
        if(dir === "T"){ state.axisScores.T += signed; state.axisScores.F -= signed; }
        else { state.axisScores.F += signed; state.axisScores.T -= signed; }
      }else if(q.axis === "JP" || q.axis === "PJ"){
        if(dir === "J"){ state.axisScores.J += signed; state.axisScores.P -= signed; }
        else { state.axisScores.P += signed; state.axisScores.J -= signed; }
      }else{
        if(typeof q.axisDir === "string"){
          const side = q.axisDir;
          if(state.axisScores.hasOwnProperty(side)){
            state.axisScores[side] += signed;
            const oppositeMap = {E:"I",I:"E",S:"N",N:"S",T:"F",F:"T",J:"P",P:"J"};
            const opp = oppositeMap[side];
            if(opp) state.axisScores[opp] -= signed;
          }
        }
      }
    }

    if(q.element && q.element !== "RECAP"){
      state.elementScores[q.element] = (state.elementScores[q.element]||0) + ans.raw * q.weight;
      if(q.phase === 3 && q.dimension){
        const key = `${q.element}::${q.dimension}`;
        state.dimensionScores[key] = (state.dimensionScores[key]||0) + ans.raw * q.weight;
      }
    }

    if(q.element === "RECAP"){
      const elems = Object.entries(state.elementScores).sort((a,b)=>b[1]-a[1]);
      const topElems = elems.slice(0,2).map(x=>x[0]).filter(Boolean);
      for(const te of topElems){
        state.elementScores[te] = (state.elementScores[te]||0) + ans.raw * q.weight * 1.2;
      }
    }

    recomputePosteriorFromScores(idx);
    recordHistory(idx);
  }

  /* --------------------------
     Recompute from start (used when going back)
     -------------------------- */
  function recomputeFromStart(){
    state.posterior = Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));
    state.quadra = computeQuadraFromPosterior(state.posterior);
    state.axisScores = {E:0,I:0,S:0,N:0,T:0,F:0,J:0,P:0};
    state.elementScores = Object.fromEntries(ELEMENTS.map(e=>[e,0]));
    state.dimensionScores = {};
    state.respStats = {n:0, mean:0, m2:0, neutral:0, extreme:0};
    state.historyTop1 = [];
    state.historyTop1Pct = [];
    state.historyGap = [];
    state.history = [];

    for(let i=0;i<state.step;i++){
      const a = state.answers[i];
      if(!a) continue;
      applyResponse(a, i);
    }
  }

  /* --------------------------
     UI: scale rendering, question rendering
     -------------------------- */
  function renderScale5(){
    elScale5.innerHTML="";
    SCALE5.forEach(s=>{
      const d=document.createElement("div");
      d.className="opt";
      d.innerHTML=`<span class="dot" aria-hidden="true"></span><span class="lab">${s.label}</span><span class="subv">${s.v>0?("+"+s.v):(""+s.v)}</span>`;
      d.addEventListener("click", ()=>{
        if(state.isAdvancing) return;
        document.querySelectorAll("#scale5 .opt").forEach(x=>x.classList.remove("sel"));
        d.classList.add("sel");
        const id = state.asked[state.step];
        const raw = s.v;
        const ans = {id:id, raw: raw, skipped:false};
        state.answers[state.step] = ans;
        goNext(false);
      });
      elScale5.appendChild(d);
    });
  }

  function renderQuestion(){
    if(state.step >= QUESTIONS.length){
      showResult();
      return;
    }
    const qIndex = state.asked[state.step];
    const q = QUESTIONS[qIndex];

    elQNo.textContent = `Q${state.step+1}`;
    elQText.textContent = q.text || "（質問文が見つかりません）";
    elScale3.style.display = "none";
    elScale5.style.display = "grid";
    renderScale5();

    if(btnNext){ btnNext.style.display = "none"; btnNext.disabled = true; }

    btnBack.disabled = (state.step === 0);

    setProgress();
    updateSide();

    state.isAdvancing = false;
  }

  /* --------------------------
     updateSide - simplified: show only rank + type + quadra label (no % / no mini bar)
     -------------------------- */
  function updateSide(){
    if(!state.livePinned) return;
    const k = getSharpenK(state.step);
    const displayPosterior = sharpenPosterior(state.posterior, k);
    const top = topN(displayPosterior,6);
    topList.innerHTML="";
    top.forEach(([t,p], idx)=>{
      const div=document.createElement("div");
      div.className="rankItem";
      // Only show rank + type + (symbol & name)
      div.innerHTML=`<b>${idx+1}位 ${t} <span style="opacity:.75;font-weight:1100">(${QSYM[QUADRA[t]]} ${QUADRA[t]})</span></b>`;
      topList.appendChild(div);
    });
  }

  /* --------------------------
     renderViz - unified implementation (keep only one)
     - Elements: keep signed centered display (sum 0)
     - Quadra: use state.quadra, sharpen for display with fixed k=3.2 then normalize and show as % with 1 decimal
     -------------------------- */
  function renderViz(topType){
    const posterior = state.posterior || Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));

    // valuedProb computation (posterior-weighted)
    const valuedProb = {};
    for(const e of ELEMENTS){
      let s = 0;
      for(const t of TYPES){
        if(QUADRA_VALUES[QUADRA[t]].has(e)) s += (posterior[t] || 0);
      }
      valuedProb[e] = clamp(s, 0, 1);
    }

    // center to -0.5..+0.5 then remove mean to force sum zero
    const raw = {};
    for(const e of ELEMENTS) raw[e] = valuedProb[e] - 0.5;
    const mean = Object.values(raw).reduce((a,b)=>a+b,0)/ELEMENTS.length;
    const centered = {};
    for(const e of ELEMENTS) centered[e] = raw[e] - mean;

    // scale to -50..+50 and round to 10-step
    let maxAbs = Math.max(...Object.values(centered).map(Math.abs)) || 1;
    const score10 = {};
    for(const e of ELEMENTS){
      const scaled = (centered[e]/maxAbs) * 50;
      const step = Math.round(scaled / 10) * 10;
      score10[e] = clamp(step, -50, 50);
    }

    // correct rounding residual so sum==0
    const ssum = Object.values(score10).reduce((a,b)=>a+b,0);
    if(ssum !== 0){
      const maxElem = Object.entries(score10).reduce((acc,cur)=>{
        if(!acc) return cur;
        return Math.abs(cur[1]) > Math.abs(acc[1]) ? cur : acc;
      }, null);
      if(maxElem){
        score10[maxElem[0]] = clamp(score10[maxElem[0]] - ssum, -50, 50);
      }
    }

    // elementViz build
    const el = document.getElementById("elementViz");
    if(el){
      el.innerHTML = ELEMENTS.map(e=>{
        const val = score10[e];
        const isValued = valuedProb[e] >= 0.5;
        const labelVal = isValued ? "価値寄り" : "非価値寄り";
        const pctText = (val>0?"+":"") + String(val) + "%";
        const leftPct = val < 0 ? Math.abs(val) : 0;
        const rightPct = val > 0 ? val : 0;
        return `
          <div class="vizRow">
            <b>${e} <span style="font-weight:700;font-size:12px;color:var(--muted);">(${labelVal})</span></b>
            <div class="vizBarSplit">
              <div class="centerLine" aria-hidden="true"></div>
              <div class="barWrap" style="width:100%;">
                <div style="flex:1;display:flex;justify-content:flex-end;padding-right:4px">
                  <div style="width:0%;max-width:50%;" data-w="${leftPct}"><div class="neg" style="width:100%"></div></div>
                </div>
                <div style="flex:1;display:flex;justify-content:flex-start;padding-left:4px">
                  <div style="width:0%;max-width:50%;" data-w="${rightPct}"><div class="pos" style="width:100%"></div></div>
                </div>
              </div>
            </div>
            <div class="vizPct" style="width:80px;text-align:right">${pctText}</div>
          </div>
        `;
      }).join("");
    }

    // Quadra display: start from state.quadra, apply sharpenDistribution with k = 3.2, normalize, then show percentages (1 decimal)
    const qRaw = state.quadra || computeQuadraFromPosterior(posterior);
    const qSharp = sharpenDistribution(qRaw, 6.0); // fixed sharpening for visible bias
    const qDisplay = normalizeVec(qSharp);

    const qvEl = document.getElementById("quadraViz");
    if(qvEl){
      const order = ["Alpha","Beta","Gamma","Delta"];
      qvEl.innerHTML = order.map(q=>{
        const pct = (Math.round(clamp(qDisplay[q],0,1)*1000)/10).toFixed(1);
        return `
          <div class="vizRow">
            <b>${QSYM[q]} ${q}</b>
            <div class="vizBar"><i style="width:0%" data-w="${pct}"></i></div>
            <div class="vizPct">${pct}%</div>
          </div>
        `;
      }).join("");
    }
    // Animate bars from 0 to target width
    requestAnimationFrame(() => {
      // Animate quadra bars
      const quadraBars = document.querySelectorAll('#quadraViz .vizBar i[data-w]');
      quadraBars.forEach(bar => {
        const targetWidth = bar.getAttribute('data-w');
        if (targetWidth) {
          bar.style.width = targetWidth + '%';
        }
      });

      // Animate element bars
      const elementBars = document.querySelectorAll('#elementViz div[data-w]');
      elementBars.forEach(bar => {
        const targetWidth = bar.getAttribute('data-w');
        if (targetWidth) {
          bar.style.width = targetWidth + '%';
        }
      });
    });

    // Return data for image generation
    return {
      elementScore10: score10,
      quadraPercent: order.reduce((acc, q) => {
        acc[q] = parseFloat((Math.round(clamp(qDisplay[q],0,1)*1000)/10).toFixed(1));
        return acc;
      }, {})
    };
  }

  /* --------------------------
     Results display (kept UX but using display sharpening for headline)
     -------------------------- */
  function adjustDisplayPercentages(topRaw, fullDisplayPosterior){
    const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));

    var p1v = (topRaw && topRaw[0] && typeof topRaw[0][1] === "number") ? topRaw[0][1] : 0;
    var p2v = (topRaw && topRaw[1] && typeof topRaw[1][1] === "number") ? topRaw[1][1] : 0;
    var p3v = (topRaw && topRaw[2] && typeof topRaw[2][1] === "number") ? topRaw[2][1] : 0;
    const p1 = Math.max(0, p1v);
    const p2 = Math.max(0, p2v);
    const p3 = Math.max(0, p3v);

    // ---- confidence: gap(1位-2位) + entropy(分布の鋭さ) から作る（※ max確率を0.6前提で扱わない） ----
    let probs = (fullDisplayPosterior && typeof fullDisplayPosterior==="object") ? fullDisplayPosterior : null;

    // fallback: topRawしか無い場合でも entropy が作れるように（最低限）
    if(!probs){
      probs = {};
      for(const [t,p] of (topRaw||[])){
        if(typeof t==="string" && typeof p==="number") probs[t]=p;
      }
    }

    // entropy (0=鋭い, 1=平たい)
    let sum=0;
    for(const k in probs){
      const v = probs[k];
      if(typeof v==="number" && v>0) sum += v;
    }
    if(sum<=0) sum=1;

    let h=0;
    for(const k in probs){
      const v = probs[k];
      if(typeof v==="number" && v>0){
        const pn = v/sum;
        h -= pn*Math.log(pn);
      }
    }
    const Hmax = Math.log(16);             // 16タイプ想定
    const h01  = clamp(h / Hmax, 0, 1);    // 0..1

    const gap    = clamp(p1 - p2, 0, 1);
    const gap01  = clamp(gap / 0.06, 0, 1);         // ここは"効き"の調整ノブ（大きいほど鈍くなる）
    const conf01 = clamp(0.7*gap01 + 0.3*(1 - h01), 0, 1);

    // conf01 を「平均75・σ≈3」になるよう z に変換（ざっくりの見た目調整）
    const z = (conf01 - 0.5) / 0.1666666667; // conf01が±0.166ズレると top1が約±3 動く
    let top1 = 75 + 3*z;
    top1 = clamp(top1, 60, 90);

    // 2位/3位は p2:p3 に按分して合計100に
    const denom  = (p2 + p3) || 1;
    const remain = 100 - top1;
    let top2 = remain * (p2 / denom);
    let top3 = remain * (p3 / denom);

    // 丸めて合計100に補正（1位の範囲は維持）
    let a = Math.round(top1);
    let b = Math.round(top2);
    let c = Math.round(top3);

    let diff = 100 - (a + b + c);
    const within = (x,lo,hi)=> x>=lo && x<=hi;

    for(let i=0;i<Math.abs(diff);i++){
      const d = diff>0 ? +1 : -1;
      if(within(b + d, 0, 100) && within(a, 60, 90)){ b += d; continue; }
      if(within(c + d, 0, 100) && within(a, 60, 90)){ c += d; continue; }
      if(within(a + d, 60, 90)){ a += d; continue; }
      b += d;
    }

    const s = a + b + c;
    if(s !== 100){
      const dd = 100 - s;
      if(within(b + dd, 0, 100)) b += dd;
      else c += dd;
    }

    return [a,b,c];
  }

  /* --------------------------
     UI wiring & flow controls
     -------------------------- */
  if(btnNext){ btnNext.style.display = "none"; btnNext.disabled = true; }

  btnSkip.addEventListener("click", ()=>{
    if(state.isAdvancing) return;
    document.querySelectorAll("#scale5 .opt, #scale3 .opt").forEach(x=>x.classList.remove("sel"));
    const id = state.asked[state.step];
    const ans = {id:id, raw:0, skipped:true};
    state.answers[state.step] = ans;
    goNext(true);
  });

  btnBack.addEventListener("click", ()=>{
    if(state.isAdvancing) return;
    goBack();
  });

  document.getElementById("btnRestart").addEventListener("click", ()=>location.reload());
  document.getElementById("btnRestartTop").addEventListener("click", ()=>location.reload());

  btnToggleLive.addEventListener("click", ()=>{ 
    state.livePinned = !state.livePinned;
    if(state.livePinned){ sideCard.classList.remove("hidden"); btnToggleLive.textContent="上位候補を非表示"; updateSide(); }
    else { sideCard.classList.add("hidden"); btnToggleLive.textContent="上位候補を表示"; }
  });

  const btnToggleFeedback = document.getElementById("btnToggleFeedback");
  const feedbackContent = document.getElementById("feedbackContent");
  if(btnToggleFeedback && feedbackContent){
    btnToggleFeedback.addEventListener("click", ()=>{
      const open = feedbackContent.classList.contains("hidden");
      if(open){ feedbackContent.classList.remove("hidden"); btnToggleFeedback.textContent="閉じる"; }
      else { feedbackContent.classList.add("hidden"); btnToggleFeedback.textContent="開く"; }
    });
  }

  /* --------------------------
     Flow helpers
     -------------------------- */
  function goNext(skipped=false){
    if(state.isAdvancing) return;
    state.isAdvancing = true;

    if(skipped){
      const id = state.asked[state.step];
      const ans = {id:id, raw:0, skipped:true};
      state.answers[state.step] = ans;
      applyResponse(ans, state.step);
    }else{
      const ans = state.answers[state.step];
      if(!ans){
        state.isAdvancing = false;
        return;
      }
      applyResponse(ans, state.step);
    }

    state.step += 1;

    if(state.step >= QUESTIONS.length){
      showResult();
      return;
    }
    renderQuestion();
  }

  function goBack(){
    if(state.step<=0) return;
    state.step -= 1;
    recomputeFromStart();
    renderQuestion();
  }

  function showResult(){
    try{
      recomputeFromStart();

      screenQuiz.style.display = "none";
      screenResult.style.display = "block";

      const topRaw = topN(state.posterior,3);
      while(topRaw.length<3) topRaw.push(["—",0]);

      // For headline display we use a display-sharpened posterior
      const kFinal = getSharpenK(state.step);
      const displayP = sharpenPosterior(state.posterior, kFinal);
      const displayForTop = topRaw.map(entry => [entry[0], displayP[entry[0]] || 0]);
      const displayPcts = adjustDisplayPercentages(displayForTop);

      const top3 = topRaw.map((entry,i)=> {
        const t = entry[0];
        return {type:t, displayPct: displayPcts[i]};
      });

      var headline = "—";
      if (top3 && top3.length > 0 && top3[0] && top3[0].type) headline = top3[0].type;
      document.getElementById("resHeadline").textContent = headline;

      const resCards=document.getElementById("resCards");
      resCards.innerHTML = "";
      
      // Create top3 grid with wallet-style cards
      const top3Grid = document.createElement("div");
      top3Grid.className = "top3Grid";
      
      top3.forEach((tp, idx)=>{
        const t = tp.type;
        const p = tp.displayPct;
        const s = typeSummary(t);
        const isPrimary = idx === 0;
        const quadra = getQuadra(t);
        
        const card = document.createElement("div");
        card.className = `topCard ${isPrimary ? 'topCard--primary' : ''}`;
        card.setAttribute('data-quadra', quadra);
        
        // Create sparkline dots based on percentage
        const sparkDots = Array(5).fill(0).map((_, i) => 
          `<span class="sparkDot ${i < Math.floor(p/20) ? 'active' : ''}"></span>`
        ).join('');
        
        card.innerHTML = `
          <div class="topCard__header">
            <div class="topCard__rank">
              <span class="rankBadge">${idx + 1}</span>
              <span>${idx + 1}位</span>
            </div>
            <div class="percentageDisplay">
              <span>${p}%</span>
              <div class="percentageBar">
                <div class="percentageBar__fill" style="width: ${p}%"></div>
              </div>
              <div class="sparkLine">${sparkDots}</div>
            </div>
          </div>
          
          <div class="${isPrimary ? 'topCard__primary' : ''}">
            <h3 class="topCard__type">${t}</h3>
            <div class="topCard__meta">
              <div class="quadraBadge" data-quadra="${quadra}">
                <span class="quadraSymbol">${QSYM[s.quadra]}</span>
                <span>${s.quadra}</span>
              </div>
            </div>
          </div>
          
          <div class="topCard__details">
            <div class="detailRow">
              <span class="detailLabel">主導</span>
              <span class="detailValue">${s.lead}</span>
            </div>
            <div class="detailRow">
              <span class="detailLabel">創造</span>
              <span class="detailValue">${s.crea}</span>
            </div>
            <div class="detailRow">
              <span class="detailLabel">価値要素</span>
              <span class="detailValue">${s.values}</span>
            </div>
          </div>
          
          <div class="topCard__description">
            ${s.oneLine}
          </div>
        `;
        
        top3Grid.appendChild(card);
      });
      
      resCards.appendChild(top3Grid);

      var topType = "ILE";
      if (top3 && top3.length > 0 && top3[0] && top3[0].type) {
        var t1 = topN(state.posterior, 1);
        if (t1 && t1.length > 0 && t1[0] && t1[0][0]) topType = t1[0][0];
      }
      renderViz(topType);
      showFeedback(topType);
      updateSide();

    }catch(e){
      const be = document.getElementById("bootError");
      if(be){ be.classList.remove("hidden"); be.textContent = String(e); }
    }finally{
      state.isAdvancing = false;
    }
  }

  /* --------------------------
     PNG download with custom layout
     -------------------------- */
  function downloadResultPng(){
    var saveBtn = document.getElementById("btnSaveImage");
    if (!saveBtn) {
      alert('保存ボタンが見つかりません');
      return;
    }

    // Disable button and show loading state
    var originalText = saveBtn.textContent;
    saveBtn.disabled = true;
    saveBtn.textContent = "生成中...";

    var exportSquare = null;

    try{
      // Get top3 from state.posterior for image generation
      var topRaw = topN(state.posterior, 3);
      while(topRaw.length < 3) topRaw.push(["—", 0]);
      
      // For display we use sharpened posterior (same as showResult)
      var kFinal = getSharpenK(state.step);
      var displayP = sharpenPosterior(state.posterior, kFinal);
      var displayForTop = topRaw.map(entry => [entry[0], displayP[entry[0]] || 0]);
      var displayPcts = adjustDisplayPercentages(displayForTop);
      
      var top3 = topRaw.map((entry, i) => {
        var t = entry[0];
        return {type: t, displayPct: displayPcts[i]};
      });

      var top1 = top3[0].type;
      var top2 = top3[1].type;
      var top3Type = top3[2].type;
      
      // Get summary for top1
      var top1Summary = typeSummary(top1);
      var top1Quadra = getQuadra(top1);
      var top2Quadra = getQuadra(top2);
      var top3Quadra = getQuadra(top3Type);

      // Get graph elements
      var elementViz = document.querySelector('#elementViz');
      var quadraViz = document.querySelector('#quadraViz');
      
      if (!elementViz || !quadraViz) {
        throw new Error('グラフ要素が見つかりません');
      }

      // Create offscreen export container
      exportSquare = document.createElement('div');
      exportSquare.id = 'exportSquare';
      exportSquare.style.cssText = `
        position: fixed;
        left: -99999px;
        top: 0;
        width: 1080px;
        height: 1080px;
        background: #0b1020;
        color: var(--text-primary);
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Hiragino Sans", "Noto Sans JP", sans-serif;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        box-sizing: border-box;
        padding: 48px;
        gap: 24px;
      `;
      
      // Add style to disable animations and transitions
      var style = document.createElement('style');
      style.textContent = `
        #exportSquare * {
          animation: none !important;
          transition: none !important;
          transform: none !important;
        }
      `;
      exportSquare.appendChild(style);

      // (A) Header section - 260px height
      var headerSection = document.createElement('div');
      headerSection.style.cssText = `
        display: flex;
        gap: 24px;
        height: 260px;
        flex-shrink: 0;
      `;

      // Left: Top1 type card (58%)
      var top1Card = document.createElement('div');
      top1Card.style.cssText = `
        flex: 0 0 58%;
        background: var(--bg-medium);
        border: 2px solid var(--border-dark);
        border-radius: 28px;
        padding: 32px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
        position: relative;
      `;
      
      top1Card.innerHTML = `
        <div style="position: absolute; top: 16px; left: 16px;">
          <span style="background: var(--q-${top1Quadra}); color: white; padding: 4px 12px; border-radius: 12px; font-size: 14px; font-weight: 700;">1位</span>
        </div>
        <div style="font-size: 72px; font-weight: 900; color: var(--q-${top1Quadra}); margin: 16px 0;">${top1}</div>
        <div style="font-size: 18px; color: var(--text-secondary);">あなたの推定タイプ</div>
      `;

      // Right: Description + Top2/3 (42%)
      var rightSection = document.createElement('div');
      rightSection.style.cssText = `
        flex: 0 0 42%;
        display: flex;
        flex-direction: column;
        gap: 16px;
      `;

      // Description
      var description = document.createElement('div');
      description.style.cssText = `
        background: var(--bg-medium);
        border: 1px solid var(--border-dark);
        border-radius: 20px;
        padding: 24px;
        flex: 1;
        display: flex;
        align-items: center;
      `;
      description.innerHTML = `
        <div style="font-size: 18px; line-height: 1.6; color: var(--text-primary);">${top1Summary.oneLine}</div>
      `;

      // Top2/3 mini cards
      var miniCards = document.createElement('div');
      miniCards.style.cssText = `
        display: flex;
        gap: 12px;
        height: 80px;
      `;

      // Top2 mini card
      var top2Card = document.createElement('div');
      top2Card.style.cssText = `
        flex: 1;
        background: var(--bg-medium);
        border: 1px solid var(--border-dark);
        border-radius: 16px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
      `;
      top2Card.innerHTML = `
        <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 4px;">2位</div>
        <div style="font-size: 24px; font-weight: 700; color: var(--q-${top2Quadra});">${top2}</div>
      `;

      // Top3 mini card
      var top3Card = document.createElement('div');
      top3Card.style.cssText = `
        flex: 1;
        background: var(--bg-medium);
        border: 1px solid var(--border-dark);
        border-radius: 16px;
        padding: 16px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
      `;
      top3Card.innerHTML = `
        <div style="font-size: 14px; color: var(--text-secondary); margin-bottom: 4px;">3位</div>
        <div style="font-size: 24px; font-weight: 700; color: var(--q-${top3Quadra});">${top3Type}</div>
      `;

      miniCards.appendChild(top2Card);
      miniCards.appendChild(top3Card);
      rightSection.appendChild(description);
      rightSection.appendChild(miniCards);

      headerSection.appendChild(top1Card);
      headerSection.appendChild(rightSection);

      // (B) Element visualization - 360px height
      var elementSection = document.createElement('div');
      elementSection.style.cssText = `
        background: var(--bg-medium);
        border: 1px solid var(--border-dark);
        border-radius: 20px;
        padding: 24px;
        height: 360px;
        flex-shrink: 0;
        overflow: hidden;
      `;
      elementSection.innerHTML = `
        <div style="font-size: 20px; font-weight: 700; margin-bottom: 16px;">情報要素（価値寄り度）</div>
        <div id="exportElementViz"></div>
      `;

      // Clone and prepare element viz
      var elementVizClone = elementViz.cloneNode(true);
      elementVizClone.id = 'exportElementViz';
      elementVizClone.style.cssText = `
        height: 280px;
        overflow: hidden;
      `;
      
      // Fix bar widths immediately
      var elementBars = elementVizClone.querySelectorAll('div[data-w]');
      elementBars.forEach(bar => {
        var targetWidth = bar.getAttribute('data-w');
        if (targetWidth) {
          bar.style.width = targetWidth + '%';
        }
      });

      // (C) Quadra visualization - 320px height
      var quadraSection = document.createElement('div');
      quadraSection.style.cssText = `
        background: var(--bg-medium);
        border: 1px solid var(--border-dark);
        border-radius: 20px;
        padding: 24px;
        height: 320px;
        flex-shrink: 0;
        overflow: hidden;
      `;
      quadraSection.innerHTML = `
        <div style="font-size: 20px; font-weight: 700; margin-bottom: 16px;">クアドラ割合（推定）</div>
        <div id="exportQuadraViz"></div>
      `;

      // Clone and prepare quadra viz
      var quadraVizClone = quadraViz.cloneNode(true);
      quadraVizClone.id = 'exportQuadraViz';
      quadraVizClone.style.cssText = `
        height: 240px;
        overflow: hidden;
      `;
      
      // Fix bar widths immediately
      var quadraBars = quadraVizClone.querySelectorAll('.vizBar i[data-w]');
      quadraBars.forEach(bar => {
        var targetWidth = bar.getAttribute('data-w');
        if (targetWidth) {
          bar.style.width = targetWidth + '%';
        }
      });

      // Replace placeholder divs with actual clones
      elementSection.replaceChild(elementVizClone, elementSection.querySelector('#exportElementViz'));
      quadraSection.replaceChild(quadraVizClone, quadraSection.querySelector('#exportQuadraViz'));

      // Assemble the export container
      exportSquare.appendChild(headerSection);
      exportSquare.appendChild(elementSection);
      exportSquare.appendChild(quadraSection);

      // Add to DOM (offscreen)
      document.body.appendChild(exportSquare);

      // Wait for layout to settle
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          // Generate image using html2canvas
          html2canvas(exportSquare, {
            width: 1080,
            height: 1080,
            scale: 2,
            backgroundColor: '#0b1020',
            useCORS: true,
            allowTaint: true,
            logging: false
          })
          .then(function(canvas) {
            // Convert canvas to blob
            canvas.toBlob(function(blob) {
              if (!blob) {
                throw new Error('画像の生成に失敗しました');
              }

              // Create file from blob
              var file = new File([blob], 'socionics_result.png', { type: 'image/png' });

              // Try to use navigator.share for mobile/iOS
              if (navigator.canShare && navigator.canShare({ files: [file] })) {
                navigator.share({
                  files: [file],
                  title: 'Socionics Result',
                  text: 'ソシオニクス診断結果'
                })
                .then(function() {
                  console.log('Shared successfully');
                })
                .catch(function(error) {
                  console.log('Share cancelled or failed:', error);
                  // Fallback to download
                  downloadBlob(blob);
                })
                .finally(function() {
                  cleanupAndRestore();
                });
              } else {
                // Fallback to traditional download for PC
                downloadBlob(blob);
                cleanupAndRestore();
              }
            }, 'image/png');
          })
          .catch(function(error) {
            console.error('Error generating PNG:', error);
            alert('画像の生成に失敗しました: ' + error.message);
            cleanupAndRestore();
          });
        });
      });

    } catch(e) {
      console.error('Error in downloadResultPng:', e);
      alert('画像保存処理でエラーが発生しました: ' + e.message);
      cleanupAndRestore();
    }

    function downloadBlob(blob) {
      var a = document.createElement('a');
      var padFn = function(n) { return String(n).padStart(2, '0'); };
      var dt = new Date();
      var filename = 'socionics_result_' + dt.getFullYear() + padFn(dt.getMonth()+1) + padFn(dt.getDate()) + '_' + padFn(dt.getHours()) + padFn(dt.getMinutes()) + padFn(dt.getSeconds()) + '.png';
      
      var url = URL.createObjectURL(blob);
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      // Delay URL revocation to ensure download starts
      setTimeout(function() {
        URL.revokeObjectURL(url);
      }, 3000);
    }

    function cleanupAndRestore() {
      // Clean up offscreen DOM
      if (exportSquare && exportSquare.parentNode) {
        exportSquare.parentNode.removeChild(exportSquare);
      }
      
      // Restore button
      saveBtn.disabled = false;
      saveBtn.textContent = originalText;
    }
  }

  /* --------------------------
     typeSummary & feedback helpers (kept)
     -------------------------- */
  function typeSummary(t){
    const q=QUADRA[t];
    const lead=MODEL[t][0], crea=MODEL[t][1];
    const values=[...QUADRA_VALUES[q]].join("・");
    const oneLine = {
      ILE:"アイデアを広げ、体系化しながら論理を構築",
      SEI:"快適さと空気を整え、調整と安定。",
      ESE:"雰囲気を温めつつ現実も回す。人を巻き込みながら整える。",
      LII:"概念の整理と整合性が強い。体系化・矛盾修正。",
      EIE:"流れの意味を掴み、感情表現で推進する。熱量と物語。",
      LSI:"規律と境界を保ち、運用で守る。ぶれない秩序。",
      SLE:"主導して切り開く実行力。決断と突破。",
      IEI:"流れと空気を読み、タイミングを作る。洞察と共鳴。",
      SEE:"関係と主導で現実を動かす。交渉・推進。",
      ILI:"流れを読み、実務を選別する。先読み×現実処理。",
      LIE:"目的へ最短で進む設計。成果へ落とす。",
      ESI:"誠実さと境界で関係を整える。筋と責任。",
      LSE:"実務と環境調整で安定推進。堅実に回す。",
      EII:"関係の質と可能性を大事にする。誠実×成長。",
      IEE:"可能性と関係で新展開を作る。接続と発想。",
      SLI:"快適さと実務で無理なく最適化。静かな改善。"
    }[t]||"—";
    return {quadra:q, lead, crea, values, oneLine};
  }

  function showFeedback(topType){
    try{
      const fbQuadEl = document.getElementById("fbQuadra");
      const fbValuesEl = document.getElementById("fbValues");
      const fbStrongEl = document.getElementById("fbStrong");
      const fbMismatchEl = document.getElementById("fbMismatch");
      if(!fbQuadEl || !fbValuesEl || !fbStrongEl || !fbMismatchEl) return;

      const q = QUADRA[topType];
      const values = [...QUADRA_VALUES[q]];
      const posterior = state.posterior || Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));
      const valuedProb = {};
      for(const e of ELEMENTS){
        let s = 0;
        for(const t of TYPES){
          if(QUADRA_VALUES[QUADRA[t]].has(e)) s += (posterior[t] || 0);
        }
        valuedProb[e] = +(s.toFixed(2));
      }
      const norm = valuedProb;
      const strong = Object.entries(norm).sort((a,b)=>b[1]-a[1]).slice(0,3).filter(([_,v])=>v>0.62);
      const mismatch = Object.entries(norm).sort((a,b)=>a[1]-b[1]).slice(0,5).filter(([_,v])=>v<0.38);

      fbQuadEl.textContent = `このクアドラは ${q} の傾向があります。`;
      fbValuesEl.innerHTML = `このクアドラは <b>${values.map(e=>e).join(" / ")}</b> を扱いやすい傾向です。`;

      fbStrongEl.innerHTML =
        (strong.length===0)
        ? "明確に強まった要素は見られません。"
        : "特に一致していた要素：<br>" +
          strong.map(([e,v])=>`・<b>${e}</b>（${v}）`).join("<br>");

      fbMismatchEl.innerHTML =
        (mismatch.length===0)
        ? "目立ったズレはありませんでした。"
        : "ズレが見られた要素：<br>" + mismatch.map(([e,v])=>`・<b>${e}</b>（${v}）`).join("<br>");
    }catch(e){
      // defensive
    }
  }

  /* --------------------------
     Startup
     -------------------------- */
  function boot(){
    state.posterior = Object.fromEntries(TYPES.map(t=>[t,1/TYPES.length]));
    state.quadra = computeQuadraFromPosterior(state.posterior);
    
    // Setup save button event listener (once)
    var saveBtn = document.getElementById("btnSaveImage");
    if (saveBtn && !saveBtn.dataset.listenerAdded) {
      saveBtn.addEventListener("click", downloadResultPng);
      saveBtn.dataset.listenerAdded = "true";
    }
    
    renderQuestion();
  }

  try{ boot(); }catch(e){
    const be=document.getElementById("bootError");
    if(be){ be.classList.remove("hidden"); be.textContent = String(e); }
  }

})();
</script>
</body>
</html>
